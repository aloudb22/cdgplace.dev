<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6266540285782069"
     crossorigin="anonymous"></script>
  <title>CDGplace</title>
<style>
  html,body{
    margin:0; padding:0; height:100%; background:#1b263b; font-family:Arial,Helvetica,sans-serif; overflow:hidden;
  }
  h1{ color:#fff; text-align:center; margin:0; padding:8px 0; text-shadow:2px 2px #000; }

  /* zone qui contient le canvas ; on transformera CET élément pour drag/zoom */
  #canvas-container{
    position:absolute; top:0; left:0; right:0; bottom:140px;
    display:flex; justify-content:center; align-items:center; overflow:visible;
    touch-action:none; /* important pour pinch/drag */
  }

  /* le canvas prend sa taille native (attribut width/height) */
  #canvas{
    display:block;
    image-rendering:pixelated;
    background:#fff;
    border:4px solid #fff;
    border-radius:8px;
    box-shadow:0 0 20px rgba(0,0,0,0.45);
    cursor:grab;
    -webkit-tap-highlight-color: transparent;
  }

/* controls fixes à gauche en verticale */
#controls {
  position: fixed;            /* reste toujours visible */
  top: 50%;                   /* centre verticalement */
  left: 0;                    /* collée au bord gauche */
  transform: translateY(-50%); /* ajuste le centrage vertical */
  background: rgba(27,38,59,0.95);
  padding: 10px 8px;
  display: flex;
  flex-direction: column;     /* vertical */
  align-items: center;        /* centre les éléments horizontalement */
  gap: 8px;
  z-index: 9999;
  box-shadow: 2px 0 10px rgba(0,0,0,0.4); /* ombre côté droit */
  border-radius: 0 8px 8px 0; /* coins arrondis côté droit uniquement */
}

/* Palette verticale dans le bandeau */
.palette {
  display: flex;
  flex-direction: column; /* pixels empilés verticalement */
  gap: 6px;               /* espace entre pixels */
  justify-content: flex-start; /* commence en haut du container */
  align-items: center;    /* centre horizontalement les pixels */
}

/* Couleurs des pixels */
.col {
  width: 30px;
  height: 30px;
  border: 2px solid #fff;
  border-radius: 6px;
  cursor: pointer;
  transition: transform 0.12s, border-color 0.12s;
}

.col:hover, .col.selected {
  transform: scale(1.15);
  border-color: #ffd700;
}

/* Bouton confirmer */
#confirm-btn {
  display: none;
  padding: 8px 14px;
  border-radius: 6px;
  background: #00ffff;
  color: #122;
  border: none;
  font-weight: 700;
  cursor: pointer;
}

#confirm-btn:active {
  transform: translateY(1px);
}

/* Statut cooldown */
#status {
  color: #fff;
  font-weight: 700;
}
</style>
</head>
<body>
  <h1>CDGplace by A.DB</h1>

  <div id="canvas-container">
    <!-- IMPORTANT: width/height attribute = logical canvas pixels (GRID_W*PIXEL_SIZE, GRID_H*PIXEL_SIZE) -->
    <canvas id="canvas" width="500" height="250"></canvas>
  </div>

  <div id="controls">
    <div class="palette" id="palette"></div>
    <button id="confirm-btn">Confirmer le pixel</button>
    <div id="status">Cooldown: 0s</div>
  </div>

<script>
/* === CONFIG === */
const PIXEL_SIZE = 4;          // chaque pixel affiché fait PIXEL_SIZE x PIXEL_SIZE réels
const VIRTUAL_W = 500;        // largeur logique (cells)
const VIRTUAL_H = 250;        // hauteur logique (cells)
const GRID_W = Math.floor(VIRTUAL_W / PIXEL_SIZE);   // nombre de cellules en x
const GRID_H = Math.floor(VIRTUAL_H / PIXEL_SIZE);   // nombre de cellules en y
// NOTE: canvas.width must equal GRID_W*PIXEL_SIZE and canvas.height = GRID_H*PIXEL_SIZE
// Ici on set canvas to 500x250 (125*4 = 500, 62*4 = 248 ≈ 250 — OK practical)
const COLORS = ['#ffffff','#000000','#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff','#582900'];

/* === DOM === */
const canvas = document.getElementById('canvas');
const container = document.getElementById('canvas-container');
const ctx = canvas.getContext('2d');
const paletteDiv = document.getElementById('palette');
const confirmBtn = document.getElementById('confirm-btn');
const statusEl = document.getElementById('status');
const controls = document.getElementById('controls');

// Bloquer toute propagation des events vers le canvas
controls.addEventListener('touchstart', e => e.stopPropagation(), {passive:true});
controls.addEventListener('touchmove', e => e.stopPropagation(), {passive:true});
controls.addEventListener('touchend', e => e.stopPropagation(), {passive:true});
controls.addEventListener('mousedown', e => e.stopPropagation());
controls.addEventListener('mousemove', e => e.stopPropagation());
controls.addEventListener('mouseup', e => e.stopPropagation());

/* ensure canvas internal size matches PIXEL_SIZE * grid */
canvas.width  = GRID_W * PIXEL_SIZE;
canvas.height = GRID_H * PIXEL_SIZE;

/* === STATE === */
let canvasState = new Array(GRID_W * GRID_H).fill('#ffffff');
let selectedColor = null;
let pendingPixel = null;
let cooldown = 0;

/* transform state (we transform container) */
let scale = 1.0;
let offsetX = 0;
let offsetY = 0;

/* drawing settings */
ctx.imageSmoothingEnabled = false;

/* === PALETTE === */
COLORS.forEach(color => {
  const d = document.createElement('div');
  d.className = 'col';
  d.style.background = color;
  d.addEventListener('click', e=>{
    e.stopPropagation(); // prevent canvas click
    selectedColor = color;
    document.querySelectorAll('.col').forEach(c=>c.classList.remove('selected'));
    d.classList.add('selected');
    // hide confirm if none selected? we show confirm only on selection+tap
  });
  paletteDiv.appendChild(d);
});
/* prevent palette clicks from reaching canvas container */
paletteDiv.addEventListener('click', e => e.stopPropagation());
confirmBtn.addEventListener('click', e => { e.stopPropagation(); if(pendingPixel) placePixel(pendingPixel.x,pendingPixel.y); });

/* === WEBSOCKET (placeholder: adapt server protocol) === */
const ws = new WebSocket(`${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}`);
let clientId = localStorage.getItem('cdgplace_id') || Math.random().toString(36).slice(2,11);
localStorage.setItem('cdgplace_id', clientId);

ws.addEventListener('open', ()=>{ console.log('WS open'); ws.send(JSON.stringify({type:'identify',id:clientId})); });
ws.addEventListener('message', ev => {
  try{
    const msg = JSON.parse(ev.data);
    if(msg.type === 'init' && Array.isArray(msg.pixels)){
      // msg.pixels expected: [{x,y,color}, ...]
      canvasState.fill('#ffffff');
      msg.pixels.forEach(p=>{
        if(p.x >=0 && p.x < GRID_W && p.y >=0 && p.y < GRID_H){
          canvasState[p.y*GRID_W + p.x] = p.color;
        }
      });
      draw();
    } else if(msg.type === 'pixel'){
      if(msg.x>=0 && msg.x<GRID_W && msg.y>=0 && msg.y<GRID_H){
        canvasState[msg.y*GRID_W + msg.x] = msg.color;
        draw();
      }
    }
  }catch(e){ console.warn('WS parse', e); }
});

/* === DRAW === */
function draw(){
  ctx.clearRect(0,0,canvas.width, canvas.height);
  // draw grid cells as PIXEL_SIZE squares
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      ctx.fillStyle = canvasState[y*GRID_W + x];
      ctx.fillRect(x*PIXEL_SIZE, y*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
    }
  }
  // selection outline
  if(pendingPixel){
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(pendingPixel.x*PIXEL_SIZE + 0.5, pendingPixel.y*PIXEL_SIZE + 0.5, PIXEL_SIZE-1, PIXEL_SIZE-1);
  }
}

/* === COORD MAPPING (handles css transform & scaling) ===
   We compute client -> canvas pixel taking into account the canvas' bounding rect.
   Then convert canvas pixel -> grid cell by dividing by PIXEL_SIZE.
*/
function clientToGrid(clientX, clientY){
  const rect = canvas.getBoundingClientRect(); // this reflects current transform
  // compute ratio from css pixels to internal canvas pixels
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const canvasPxX = (clientX - rect.left) * scaleX;
  const canvasPxY = (clientY - rect.top) * scaleY;
  let gx = Math.floor(canvasPxX / PIXEL_SIZE);
  let gy = Math.floor(canvasPxY / PIXEL_SIZE);
  gx = Math.min(Math.max(0, gx), GRID_W-1);
  gy = Math.min(Math.max(0, gy), GRID_H-1);
  return {x: gx, y: gy};
}

/* === PLACER PIXEL === */
function placePixel(x,y){
  if(!selectedColor) return;
  if(cooldown>0) return;
  canvasState[y*GRID_W + x] = selectedColor;
  pendingPixel = null;
  draw();
  // send to server
  ws.send(JSON.stringify({type:'place', x, y, color:selectedColor}));
  cooldown = 3;
  statusEl.textContent = `Cooldown: ${cooldown}s`;
  confirmBtn.style.display = 'none';
}

/* cooldown timer */
setInterval(()=>{
  if(cooldown>0){ cooldown--; statusEl.textContent = `Cooldown: ${cooldown}s`; }
},1000);

/* === TRANSFORM (drag/zoom) applied on container === */
function updateTransform(){
  container.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
}

/* START centered */
function centerCanvas(){
  // center using container's visible rect (canvas has natural size canvas.width/canvas.height)
  offsetX = (window.innerWidth - (canvas.width * scale)) / 2;
  offsetY = (window.innerHeight - 140 - (canvas.height * scale)) / 2;
  updateTransform();
}
window.addEventListener('load', ()=>{ centerCanvas(); draw(); });

/* === MOUSE DRAG (desktop) === */
let dragging = false;
let lastMouseX = 0, lastMouseY = 0;
canvas.addEventListener('mousedown', e=>{
  // left button only
  if(e.button !== 0) return;
  dragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  // stop native behavior
  e.preventDefault();
});
window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx = e.clientX - lastMouseX;
  const dy = e.clientY - lastMouseY;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  offsetX += dx;
  offsetY += dy;
  updateTransform();
});
window.addEventListener('mouseup', e=>{
  if(dragging){ dragging = false; return; }
});

/* click to select pixel (desktop) */
canvas.addEventListener('click', e=>{
  // ignore clicks that already came from palette
  if(!selectedColor) return; // require color chosen
  pendingPixel = clientToGrid(e.clientX, e.clientY);
  draw();
  confirmBtn.style.display = 'inline-block';
});

/* wheel zoom (desktop) - zoom towards mouse pointer */
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const cssToCanvasX = mx * (canvas.width / rect.width);
  const cssToCanvasY = my * (canvas.height / rect.height);

  const delta = e.deltaY < 0 ? 1.08 : 0.92;
  // compute new offsets such that point under cursor remains under cursor
  offsetX = (offsetX - cssToCanvasX)*(delta) + cssToCanvasX;
  offsetY = (offsetY - cssToCanvasY)*(delta) + cssToCanvasY;
  scale *= delta;
  updateTransform();
});

/* === TOUCH: drag, pinch, tap === */
let touchDragging = false;
let touchStartX = 0, touchStartY = 0;
let lastDist = 0;
let pinchCenter = null;
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length === 1){
    touchDragging = false;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  } else if(e.touches.length === 2){
    // start pinch
    lastDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    pinchCenter = {
      x: (e.touches[0].clientX + e.touches[1].clientX)/2,
      y: (e.touches[0].clientY + e.touches[1].clientY)/2
    };
  }
}, {passive:false});

canvas.addEventListener('touchmove', e=>{
  if(e.touches.length === 1){
    const dx = e.touches[0].clientX - touchStartX;
    const dy = e.touches[0].clientY - touchStartY;
    if(!touchDragging && Math.abs(dx)+Math.abs(dy) > 6) touchDragging = true;
    if(touchDragging){
      offsetX += dx;
      offsetY += dy;
      updateTransform();
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  } else if(e.touches.length === 2){
    e.preventDefault(); // prevent page zoom
    const dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const center = {
      x: (e.touches[0].clientX + e.touches[1].clientX)/2,
      y: (e.touches[0].clientY + e.touches[1].clientY)/2
    };
    const delta = dist / lastDist;
    // convert center to canvas internal pixels (like wheel)
    const rect = canvas.getBoundingClientRect();
    const mx = center.x - rect.left;
    const my = center.y - rect.top;
    const cssToCanvasX = mx * (canvas.width / rect.width);
    const cssToCanvasY = my * (canvas.height / rect.height);

    offsetX = (offsetX - cssToCanvasX)*(delta) + cssToCanvasX;
    offsetY = (offsetY - cssToCanvasY)*(delta) + cssToCanvasY;
    scale *= delta;
    lastDist = dist;
    updateTransform();
  }
}, {passive:false});

canvas.addEventListener('touchend', e=>{
  // single tap -> select pixel only if it was a tap (not drag)
  if(e.changedTouches.length === 1 && !touchDragging && !pinchCenter){
    const t = e.changedTouches[0];
    if(selectedColor){
      pendingPixel = clientToGrid(t.clientX, t.clientY);
      draw();
      confirmBtn.style.display = 'inline-block';
    }
  }
  // reset pinch if touches less than 2
  if(e.touches.length < 2){ lastDist = 0; pinchCenter = null; }
});

/* prevent double-tap to zoom on iOS */
let lastTouchTime = 0;
document.addEventListener('touchstart', function(e){
  const now = Date.now();
  if(now - lastTouchTime < 300){
    e.preventDefault();
  }
  lastTouchTime = now;
}, {passive:false});

/* helper: map touch/mouse client -> grid (internal canvas pixels then cell) */
function clientToGrid(clientX, clientY){
  return clientToGrid; // keep backward compatibility in case of older calls
}

/* small helper alias used by touchend earlier */
function clientToGrid(clientX, clientY){ return clientToGrid_impl(clientX, clientY); }
function clientToGrid_impl(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const canvasPxX = (clientX - rect.left) * scaleX;
  const canvasPxY = (clientY - rect.top) * scaleY;
  let gx = Math.floor(canvasPxX / PIXEL_SIZE);
  let gy = Math.floor(canvasPxY / PIXEL_SIZE);
  gx = Math.min(Math.max(0, gx), GRID_W-1);
  gy = Math.min(Math.max(0, gy), GRID_H-1);
  return {x:gx, y:gy};
}

/* expose the same function used on click */
function getGridCoords(clientX, clientY){ return clientToGrid_impl(clientX, clientY); }

/* draw initial */
centerCanvas();
draw();

</script>
</body>
  </html>
